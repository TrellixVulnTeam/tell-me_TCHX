{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst EE = require('events').EventEmitter;\n\nconst Minimatch = require('minimatch').Minimatch;\n\nclass Walker extends EE {\n  constructor(opts) {\n    opts = opts || {};\n    super(opts); // set to true if this.path is a symlink, whether follow is true or not\n\n    this.isSymbolicLink = opts.isSymbolicLink;\n    this.path = opts.path || process.cwd();\n    this.basename = path.basename(this.path);\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore'];\n    this.ignoreRules = {};\n    this.parent = opts.parent || null;\n    this.includeEmpty = !!opts.includeEmpty;\n    this.root = this.parent ? this.parent.root : this.path;\n    this.follow = !!opts.follow;\n    this.result = this.parent ? this.parent.result : new Set();\n    this.entries = null;\n    this.sawError = false;\n  }\n\n  sort(a, b) {\n    return a.localeCompare(b, 'en');\n  }\n\n  emit(ev, data) {\n    let ret = false;\n\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') {\n        this.sawError = true;\n      } else if (ev === 'done' && !this.parent) {\n        data = Array.from(data).map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort);\n        this.result = data;\n      }\n\n      if (ev === 'error' && this.parent) {\n        ret = this.parent.emit('error', data);\n      } else {\n        ret = super.emit(ev, data);\n      }\n    }\n\n    return ret;\n  }\n\n  start() {\n    fs.readdir(this.path, (er, entries) => er ? this.emit('error', er) : this.onReaddir(entries));\n    return this;\n  }\n\n  isIgnoreFile(e) {\n    return e !== '.' && e !== '..' && this.ignoreFiles.indexOf(e) !== -1;\n  }\n\n  onReaddir(entries) {\n    this.entries = entries;\n\n    if (entries.length === 0) {\n      if (this.includeEmpty) {\n        this.result.add(this.path.substr(this.root.length + 1));\n      }\n\n      this.emit('done', this.result);\n    } else {\n      const hasIg = this.entries.some(e => this.isIgnoreFile(e));\n\n      if (hasIg) {\n        this.addIgnoreFiles();\n      } else {\n        this.filterEntries();\n      }\n    }\n  }\n\n  addIgnoreFiles() {\n    const newIg = this.entries.filter(e => this.isIgnoreFile(e));\n    let igCount = newIg.length;\n\n    const then = _ => {\n      if (--igCount === 0) {\n        this.filterEntries();\n      }\n    };\n\n    newIg.forEach(e => this.addIgnoreFile(e, then));\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    fs.readFile(ig, 'utf8', (er, data) => er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then));\n  }\n\n  onReadIgnoreFile(file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true\n    };\n    const rules = data.split(/\\r?\\n/).filter(line => !/^#|^$/.test(line.trim())).map(r => new Minimatch(r, mmopt));\n    this.ignoreRules[file] = rules;\n    then();\n  }\n\n  filterEntries() {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry);\n      const passDir = this.filterEntry(entry, true);\n      return passFile || passDir ? [entry, passFile, passDir] : false;\n    }).filter(e => e); // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n\n    let entryCount = filtered.length;\n\n    if (entryCount === 0) {\n      this.emit('done', this.result);\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) {\n          this.emit('done', this.result);\n        }\n      };\n\n      filtered.forEach(filt => {\n        const entry = filt[0];\n        const file = filt[1];\n        const dir = filt[2];\n        this.stat({\n          entry,\n          file,\n          dir\n        }, then);\n      });\n    }\n  }\n\n  onstat(_ref, then) {\n    let {\n      st,\n      entry,\n      file,\n      dir,\n      isSymbolicLink\n    } = _ref;\n    const abs = this.path + '/' + entry;\n\n    if (!st.isDirectory()) {\n      if (file) {\n        this.result.add(abs.substr(this.root.length + 1));\n      }\n\n      then();\n    } else {\n      // is a directory\n      if (dir) {\n        this.walker(entry, {\n          isSymbolicLink\n        }, then);\n      } else {\n        then();\n      }\n    }\n  }\n\n  stat(_ref2, then) {\n    let {\n      entry,\n      file,\n      dir\n    } = _ref2;\n    const abs = this.path + '/' + entry;\n    fs.lstat(abs, (er, st) => {\n      if (er) {\n        this.emit('error', er);\n      } else {\n        const isSymbolicLink = st.isSymbolicLink();\n\n        if (this.follow && isSymbolicLink) {\n          fs.stat(abs, (er, st) => {\n            if (er) {\n              this.emit('error', er);\n            } else {\n              this.onstat({\n                st,\n                entry,\n                file,\n                dir,\n                isSymbolicLink\n              }, then);\n            }\n          });\n        } else {\n          this.onstat({\n            st,\n            entry,\n            file,\n            dir,\n            isSymbolicLink\n          }, then);\n        }\n      }\n    });\n  }\n\n  walkerOpt(entry, opts) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty,\n      ...opts\n    };\n  }\n\n  walker(entry, opts, then) {\n    new Walker(this.walkerOpt(entry, opts)).on('done', then).start();\n  }\n\n  filterEntry(entry, partial) {\n    let included = true; // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + '/' + entry;\n      included = this.parent.filterEntry(pt, partial);\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) || rule.match(entry) || !!partial && (rule.match('/' + entry + '/') || rule.match(entry + '/')) || !!partial && rule.negate && (rule.match('/' + entry, true) || rule.match(entry, true));\n\n            if (match) {\n              included = rule.negate;\n            }\n          }\n        });\n      }\n    });\n    return included;\n  }\n\n}\n\nclass WalkerSync extends Walker {\n  start() {\n    this.onReaddir(fs.readdirSync(this.path));\n    return this;\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then);\n  }\n\n  stat(_ref3, then) {\n    let {\n      entry,\n      file,\n      dir\n    } = _ref3;\n    const abs = this.path + '/' + entry;\n    let st = fs.lstatSync(abs);\n    const isSymbolicLink = st.isSymbolicLink();\n\n    if (this.follow && isSymbolicLink) {\n      st = fs.statSync(abs);\n    } // console.error('STAT SYNC', {st, entry, file, dir, isSymbolicLink, then})\n\n\n    this.onstat({\n      st,\n      entry,\n      file,\n      dir,\n      isSymbolicLink\n    }, then);\n  }\n\n  walker(entry, opts, then) {\n    new WalkerSync(this.walkerOpt(entry, opts)).start();\n    then();\n  }\n\n}\n\nconst walk = (opts, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(opts).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\n\nconst walkSync = opts => new WalkerSync(opts).start().result;\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.Walker = Walker;\nwalk.WalkerSync = WalkerSync;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/ignore-walk/index.js"],"names":["fs","require","path","EE","EventEmitter","Minimatch","Walker","constructor","opts","isSymbolicLink","process","cwd","basename","ignoreFiles","ignoreRules","parent","includeEmpty","root","follow","result","Set","entries","sawError","sort","a","b","localeCompare","emit","ev","data","ret","Array","from","map","e","test","start","readdir","er","onReaddir","isIgnoreFile","indexOf","length","add","substr","hasIg","some","addIgnoreFiles","filterEntries","newIg","filter","igCount","then","_","forEach","addIgnoreFile","file","ig","resolve","readFile","onReadIgnoreFile","mmopt","matchBase","dot","flipNegate","nocase","rules","split","line","trim","r","filtered","entry","passFile","filterEntry","passDir","entryCount","filt","dir","stat","onstat","st","abs","isDirectory","walker","lstat","walkerOpt","on","partial","included","pt","f","rule","negate","match","WalkerSync","readdirSync","readFileSync","lstatSync","statSync","walk","callback","p","Promise","reject","res","walkSync","module","exports","sync"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst EE = require('events').EventEmitter\nconst Minimatch = require('minimatch').Minimatch\n\nclass Walker extends EE {\n  constructor (opts) {\n    opts = opts || {}\n    super(opts)\n    // set to true if this.path is a symlink, whether follow is true or not\n    this.isSymbolicLink = opts.isSymbolicLink\n    this.path = opts.path || process.cwd()\n    this.basename = path.basename(this.path)\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore']\n    this.ignoreRules = {}\n    this.parent = opts.parent || null\n    this.includeEmpty = !!opts.includeEmpty\n    this.root = this.parent ? this.parent.root : this.path\n    this.follow = !!opts.follow\n    this.result = this.parent ? this.parent.result : new Set()\n    this.entries = null\n    this.sawError = false\n  }\n\n  sort (a, b) {\n    return a.localeCompare(b, 'en')\n  }\n\n  emit (ev, data) {\n    let ret = false\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') {\n        this.sawError = true\n      } else if (ev === 'done' && !this.parent) {\n        data = Array.from(data)\n          .map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort)\n        this.result = data\n      }\n\n      if (ev === 'error' && this.parent) {\n        ret = this.parent.emit('error', data)\n      } else {\n        ret = super.emit(ev, data)\n      }\n    }\n    return ret\n  }\n\n  start () {\n    fs.readdir(this.path, (er, entries) =>\n      er ? this.emit('error', er) : this.onReaddir(entries))\n    return this\n  }\n\n  isIgnoreFile (e) {\n    return e !== '.' &&\n      e !== '..' &&\n      this.ignoreFiles.indexOf(e) !== -1\n  }\n\n  onReaddir (entries) {\n    this.entries = entries\n    if (entries.length === 0) {\n      if (this.includeEmpty) {\n        this.result.add(this.path.substr(this.root.length + 1))\n      }\n      this.emit('done', this.result)\n    } else {\n      const hasIg = this.entries.some(e =>\n        this.isIgnoreFile(e))\n\n      if (hasIg) {\n        this.addIgnoreFiles()\n      } else {\n        this.filterEntries()\n      }\n    }\n  }\n\n  addIgnoreFiles () {\n    const newIg = this.entries\n      .filter(e => this.isIgnoreFile(e))\n\n    let igCount = newIg.length\n    const then = _ => {\n      if (--igCount === 0) {\n        this.filterEntries()\n      }\n    }\n\n    newIg.forEach(e => this.addIgnoreFile(e, then))\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    fs.readFile(ig, 'utf8', (er, data) =>\n      er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then))\n  }\n\n  onReadIgnoreFile (file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true,\n    }\n    const rules = data.split(/\\r?\\n/)\n      .filter(line => !/^#|^$/.test(line.trim()))\n      .map(r => new Minimatch(r, mmopt))\n\n    this.ignoreRules[file] = rules\n\n    then()\n  }\n\n  filterEntries () {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry)\n      const passDir = this.filterEntry(entry, true)\n      return (passFile || passDir) ? [entry, passFile, passDir] : false\n    }).filter(e => e)\n\n    // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n    let entryCount = filtered.length\n    if (entryCount === 0) {\n      this.emit('done', this.result)\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) {\n          this.emit('done', this.result)\n        }\n      }\n      filtered.forEach(filt => {\n        const entry = filt[0]\n        const file = filt[1]\n        const dir = filt[2]\n        this.stat({ entry, file, dir }, then)\n      })\n    }\n  }\n\n  onstat ({ st, entry, file, dir, isSymbolicLink }, then) {\n    const abs = this.path + '/' + entry\n    if (!st.isDirectory()) {\n      if (file) {\n        this.result.add(abs.substr(this.root.length + 1))\n      }\n      then()\n    } else {\n      // is a directory\n      if (dir) {\n        this.walker(entry, { isSymbolicLink }, then)\n      } else {\n        then()\n      }\n    }\n  }\n\n  stat ({ entry, file, dir }, then) {\n    const abs = this.path + '/' + entry\n    fs.lstat(abs, (er, st) => {\n      if (er) {\n        this.emit('error', er)\n      } else {\n        const isSymbolicLink = st.isSymbolicLink()\n        if (this.follow && isSymbolicLink) {\n          fs.stat(abs, (er, st) => {\n            if (er) {\n              this.emit('error', er)\n            } else {\n              this.onstat({ st, entry, file, dir, isSymbolicLink }, then)\n            }\n          })\n        } else {\n          this.onstat({ st, entry, file, dir, isSymbolicLink }, then)\n        }\n      }\n    })\n  }\n\n  walkerOpt (entry, opts) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty,\n      ...opts,\n    }\n  }\n\n  walker (entry, opts, then) {\n    new Walker(this.walkerOpt(entry, opts)).on('done', then).start()\n  }\n\n  filterEntry (entry, partial) {\n    let included = true\n\n    // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + '/' + entry\n      included = this.parent.filterEntry(pt, partial)\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) ||\n              rule.match(entry) ||\n              (!!partial && (\n                rule.match('/' + entry + '/') ||\n                rule.match(entry + '/'))) ||\n              (!!partial && rule.negate && (\n                rule.match('/' + entry, true) ||\n                rule.match(entry, true)))\n\n            if (match) {\n              included = rule.negate\n            }\n          }\n        })\n      }\n    })\n\n    return included\n  }\n}\n\nclass WalkerSync extends Walker {\n  start () {\n    this.onReaddir(fs.readdirSync(this.path))\n    return this\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then)\n  }\n\n  stat ({ entry, file, dir }, then) {\n    const abs = this.path + '/' + entry\n    let st = fs.lstatSync(abs)\n    const isSymbolicLink = st.isSymbolicLink()\n    if (this.follow && isSymbolicLink) {\n      st = fs.statSync(abs)\n    }\n\n    // console.error('STAT SYNC', {st, entry, file, dir, isSymbolicLink, then})\n    this.onstat({ st, entry, file, dir, isSymbolicLink }, then)\n  }\n\n  walker (entry, opts, then) {\n    new WalkerSync(this.walkerOpt(entry, opts)).start()\n    then()\n  }\n}\n\nconst walk = (opts, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(opts).on('done', resolve).on('error', reject).start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nconst walkSync = opts => new WalkerSync(opts).start().result\n\nmodule.exports = walk\nwalk.sync = walkSync\nwalk.Walker = Walker\nwalk.WalkerSync = WalkerSync\n"]},"metadata":{},"sourceType":"script"}