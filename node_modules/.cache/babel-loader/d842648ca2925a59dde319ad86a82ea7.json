{"ast":null,"code":"const os = require('os');\n\nconst log = require('./log-shim.js');\n\nconst errorMessage = require('./error-message.js');\n\nconst replaceInfo = require('./replace-info.js');\n\nconst messageText = msg => msg.map(line => line.slice(1).join(' ')).join('\\n');\n\nlet npm = null; // set by the cli\n\nlet exitHandlerCalled = false;\nlet showLogFileMessage = false;\nprocess.on('exit', code => {\n  log.disableProgress(); // process.emit is synchronous, so the timeEnd handler will run before the\n  // unfinished timer check below\n\n  process.emit('timeEnd', 'npm');\n  const hasNpm = !!npm;\n  const hasLoadedNpm = hasNpm && npm.config.loaded; // Unfinished timers can be read before config load\n\n  if (hasNpm) {\n    for (const [name, timer] of npm.unfinishedTimers) {\n      log.verbose('unfinished npm timer', name, timer);\n    }\n  }\n\n  if (!code) {\n    log.info('ok');\n  } else {\n    log.verbose('code', code);\n  }\n\n  if (!exitHandlerCalled) {\n    process.exitCode = code || 1;\n    log.error('', 'Exit handler never called!');\n    console.error('');\n    log.error('', 'This is an error with npm itself. Please report this error at:');\n    log.error('', '    <https://github.com/npm/cli/issues>');\n    showLogFileMessage = true;\n  } // In timing mode we always show the log file message\n\n\n  if (hasLoadedNpm && npm.config.get('timing')) {\n    showLogFileMessage = true;\n  } // npm must be loaded to know where the log file was written\n\n\n  if (showLogFileMessage && hasLoadedNpm) {\n    // just a line break\n    if (log.levels[log.level] <= log.levels.error) {\n      console.error('');\n    }\n\n    log.error('', ['A complete log of this run can be found in:', ...npm.logFiles.map(f => '    ' + f)].join('\\n'));\n  } // This removes any listeners npm setup and writes files if necessary\n  // This is mostly used for tests to avoid max listener warnings\n\n\n  if (hasLoadedNpm) {\n    npm.unload();\n  } // these are needed for the tests to have a clean slate in each test case\n\n\n  exitHandlerCalled = false;\n  showLogFileMessage = false;\n});\n\nconst exitHandler = err => {\n  exitHandlerCalled = true;\n  log.disableProgress();\n  const hasNpm = !!npm;\n  const hasLoadedNpm = hasNpm && npm.config.loaded;\n\n  if (!hasNpm) {\n    err = err || new Error('Exit prior to setting npm in exit handler');\n    console.error(err.stack || err.message);\n    return process.exit(1);\n  }\n\n  if (!hasLoadedNpm) {\n    err = err || new Error('Exit prior to config file resolving.');\n    console.error(err.stack || err.message);\n  } // only show the notification if it finished.\n\n\n  if (typeof npm.updateNotification === 'string') {\n    const {\n      level\n    } = log;\n    log.level = 'notice';\n    log.notice('', npm.updateNotification);\n    log.level = level;\n  }\n\n  let exitCode;\n  let noLogMessage;\n\n  if (err) {\n    exitCode = 1; // if we got a command that just shells out to something else, then it\n    // will presumably print its own errors and exit with a proper status\n    // code if there's a problem.  If we got an error with a code=0, then...\n    // something else went wrong along the way, so maybe an npm problem?\n\n    const isShellout = npm.shelloutCommands.includes(npm.command);\n    const quietShellout = isShellout && typeof err.code === 'number' && err.code;\n\n    if (quietShellout) {\n      exitCode = err.code;\n      noLogMessage = true;\n    } else if (typeof err === 'string') {\n      // XXX: we should stop throwing strings\n      log.error('', err);\n      noLogMessage = true;\n    } else if (!(err instanceof Error)) {\n      log.error('weird error', err);\n      noLogMessage = true;\n    } else {\n      if (!err.code) {\n        const matchErrorCode = err.message.match(/^(?:Error: )?(E[A-Z]+)/);\n        err.code = matchErrorCode && matchErrorCode[1];\n      }\n\n      for (const k of ['type', 'stack', 'statusCode', 'pkgid']) {\n        const v = err[k];\n\n        if (v) {\n          log.verbose(k, replaceInfo(v));\n        }\n      }\n\n      const args = replaceInfo(process.argv);\n      log.verbose('cwd', process.cwd());\n      log.verbose('', os.type() + ' ' + os.release());\n      log.verbose('argv', args.map(JSON.stringify).join(' '));\n      log.verbose('node', process.version);\n      log.verbose('npm ', 'v' + npm.version);\n\n      for (const k of ['code', 'syscall', 'file', 'path', 'dest', 'errno']) {\n        const v = err[k];\n\n        if (v) {\n          log.error(k, v);\n        }\n      }\n\n      const msg = errorMessage(err, npm);\n\n      for (const errline of [...msg.summary, ...msg.detail]) {\n        log.error(...errline);\n      }\n\n      if (hasLoadedNpm && npm.config.get('json')) {\n        const error = {\n          error: {\n            code: err.code,\n            summary: messageText(msg.summary),\n            detail: messageText(msg.detail)\n          }\n        };\n        console.error(JSON.stringify(error, null, 2));\n      }\n\n      if (typeof err.errno === 'number') {\n        exitCode = err.errno;\n      } else if (typeof err.code === 'number') {\n        exitCode = err.code;\n      }\n    }\n  }\n\n  log.verbose('exit', exitCode || 0);\n  showLogFileMessage = log.level === 'silent' || noLogMessage ? false : !!exitCode; // explicitly call process.exit now so we don't hang on things like the\n  // update notifier, also flush stdout beforehand because process.exit doesn't\n  // wait for that to happen.\n\n  process.stdout.write('', () => process.exit(exitCode));\n};\n\nmodule.exports = exitHandler;\n\nmodule.exports.setNpm = n => {\n  npm = n;\n};","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/lib/utils/exit-handler.js"],"names":["os","require","log","errorMessage","replaceInfo","messageText","msg","map","line","slice","join","npm","exitHandlerCalled","showLogFileMessage","process","on","code","disableProgress","emit","hasNpm","hasLoadedNpm","config","loaded","name","timer","unfinishedTimers","verbose","info","exitCode","error","console","get","levels","level","logFiles","f","unload","exitHandler","err","Error","stack","message","exit","updateNotification","notice","noLogMessage","isShellout","shelloutCommands","includes","command","quietShellout","matchErrorCode","match","k","v","args","argv","cwd","type","release","JSON","stringify","version","errline","summary","detail","errno","stdout","write","module","exports","setNpm","n"],"mappings":"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","sourcesContent":["const os = require('os')\nconst log = require('./log-shim.js')\n\nconst errorMessage = require('./error-message.js')\nconst replaceInfo = require('./replace-info.js')\n\nconst messageText = msg => msg.map(line => line.slice(1).join(' ')).join('\\n')\n\nlet npm = null // set by the cli\nlet exitHandlerCalled = false\nlet showLogFileMessage = false\n\nprocess.on('exit', code => {\n  log.disableProgress()\n\n  // process.emit is synchronous, so the timeEnd handler will run before the\n  // unfinished timer check below\n  process.emit('timeEnd', 'npm')\n\n  const hasNpm = !!npm\n  const hasLoadedNpm = hasNpm && npm.config.loaded\n\n  // Unfinished timers can be read before config load\n  if (hasNpm) {\n    for (const [name, timer] of npm.unfinishedTimers) {\n      log.verbose('unfinished npm timer', name, timer)\n    }\n  }\n\n  if (!code) {\n    log.info('ok')\n  } else {\n    log.verbose('code', code)\n  }\n\n  if (!exitHandlerCalled) {\n    process.exitCode = code || 1\n    log.error('', 'Exit handler never called!')\n    console.error('')\n    log.error('', 'This is an error with npm itself. Please report this error at:')\n    log.error('', '    <https://github.com/npm/cli/issues>')\n    showLogFileMessage = true\n  }\n\n  // In timing mode we always show the log file message\n  if (hasLoadedNpm && npm.config.get('timing')) {\n    showLogFileMessage = true\n  }\n\n  // npm must be loaded to know where the log file was written\n  if (showLogFileMessage && hasLoadedNpm) {\n    // just a line break\n    if (log.levels[log.level] <= log.levels.error) {\n      console.error('')\n    }\n\n    log.error(\n      '',\n      [\n        'A complete log of this run can be found in:',\n        ...npm.logFiles.map(f => '    ' + f),\n      ].join('\\n')\n    )\n  }\n\n  // This removes any listeners npm setup and writes files if necessary\n  // This is mostly used for tests to avoid max listener warnings\n  if (hasLoadedNpm) {\n    npm.unload()\n  }\n\n  // these are needed for the tests to have a clean slate in each test case\n  exitHandlerCalled = false\n  showLogFileMessage = false\n})\n\nconst exitHandler = err => {\n  exitHandlerCalled = true\n\n  log.disableProgress()\n\n  const hasNpm = !!npm\n  const hasLoadedNpm = hasNpm && npm.config.loaded\n\n  if (!hasNpm) {\n    err = err || new Error('Exit prior to setting npm in exit handler')\n    console.error(err.stack || err.message)\n    return process.exit(1)\n  }\n\n  if (!hasLoadedNpm) {\n    err = err || new Error('Exit prior to config file resolving.')\n    console.error(err.stack || err.message)\n  }\n\n  // only show the notification if it finished.\n  if (typeof npm.updateNotification === 'string') {\n    const { level } = log\n    log.level = 'notice'\n    log.notice('', npm.updateNotification)\n    log.level = level\n  }\n\n  let exitCode\n  let noLogMessage\n\n  if (err) {\n    exitCode = 1\n    // if we got a command that just shells out to something else, then it\n    // will presumably print its own errors and exit with a proper status\n    // code if there's a problem.  If we got an error with a code=0, then...\n    // something else went wrong along the way, so maybe an npm problem?\n    const isShellout = npm.shelloutCommands.includes(npm.command)\n    const quietShellout = isShellout && typeof err.code === 'number' && err.code\n    if (quietShellout) {\n      exitCode = err.code\n      noLogMessage = true\n    } else if (typeof err === 'string') {\n      // XXX: we should stop throwing strings\n      log.error('', err)\n      noLogMessage = true\n    } else if (!(err instanceof Error)) {\n      log.error('weird error', err)\n      noLogMessage = true\n    } else {\n      if (!err.code) {\n        const matchErrorCode = err.message.match(/^(?:Error: )?(E[A-Z]+)/)\n        err.code = matchErrorCode && matchErrorCode[1]\n      }\n\n      for (const k of ['type', 'stack', 'statusCode', 'pkgid']) {\n        const v = err[k]\n        if (v) {\n          log.verbose(k, replaceInfo(v))\n        }\n      }\n\n      const args = replaceInfo(process.argv)\n      log.verbose('cwd', process.cwd())\n      log.verbose('', os.type() + ' ' + os.release())\n      log.verbose('argv', args.map(JSON.stringify).join(' '))\n      log.verbose('node', process.version)\n      log.verbose('npm ', 'v' + npm.version)\n\n      for (const k of ['code', 'syscall', 'file', 'path', 'dest', 'errno']) {\n        const v = err[k]\n        if (v) {\n          log.error(k, v)\n        }\n      }\n\n      const msg = errorMessage(err, npm)\n      for (const errline of [...msg.summary, ...msg.detail]) {\n        log.error(...errline)\n      }\n\n      if (hasLoadedNpm && npm.config.get('json')) {\n        const error = {\n          error: {\n            code: err.code,\n            summary: messageText(msg.summary),\n            detail: messageText(msg.detail),\n          },\n        }\n        console.error(JSON.stringify(error, null, 2))\n      }\n\n      if (typeof err.errno === 'number') {\n        exitCode = err.errno\n      } else if (typeof err.code === 'number') {\n        exitCode = err.code\n      }\n    }\n  }\n\n  log.verbose('exit', exitCode || 0)\n\n  showLogFileMessage = log.level === 'silent' || noLogMessage\n    ? false\n    : !!exitCode\n\n  // explicitly call process.exit now so we don't hang on things like the\n  // update notifier, also flush stdout beforehand because process.exit doesn't\n  // wait for that to happen.\n  process.stdout.write('', () => process.exit(exitCode))\n}\n\nmodule.exports = exitHandler\nmodule.exports.setNpm = n => {\n  npm = n\n}\n"]},"metadata":{},"sourceType":"script"}