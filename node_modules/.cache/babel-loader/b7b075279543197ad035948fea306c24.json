{"ast":null,"code":"const parseJSON = require('json-parse-even-better-errors');\n\nconst {\n  diff\n} = require('just-diff');\n\nconst {\n  diffApply\n} = require('just-diff-apply');\n\nconst globalObjectProperties = Object.getOwnPropertyNames(Object.prototype);\n\nconst stripBOM = content => {\n  content = content.toString(); // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n\n  return content;\n};\n\nconst PARENT_RE = /\\|{7,}/g;\nconst OURS_RE = /<{7,}/g;\nconst THEIRS_RE = /={7,}/g;\nconst END_RE = />{7,}/g;\n\nconst isDiff = str => str.match(OURS_RE) && str.match(THEIRS_RE) && str.match(END_RE);\n\nconst parseConflictJSON = (str, reviver, prefer) => {\n  prefer = prefer || 'ours';\n\n  if (prefer !== 'theirs' && prefer !== 'ours') {\n    throw new TypeError('prefer param must be \"ours\" or \"theirs\" if set');\n  }\n\n  str = stripBOM(str);\n\n  if (!isDiff(str)) {\n    return parseJSON(str);\n  }\n\n  const pieces = str.split(/[\\n\\r]+/g).reduce((acc, line) => {\n    if (line.match(PARENT_RE)) {\n      acc.state = 'parent';\n    } else if (line.match(OURS_RE)) {\n      acc.state = 'ours';\n    } else if (line.match(THEIRS_RE)) {\n      acc.state = 'theirs';\n    } else if (line.match(END_RE)) {\n      acc.state = 'top';\n    } else {\n      if (acc.state === 'top' || acc.state === 'ours') {\n        acc.ours += line;\n      }\n\n      if (acc.state === 'top' || acc.state === 'theirs') {\n        acc.theirs += line;\n      }\n\n      if (acc.state === 'top' || acc.state === 'parent') {\n        acc.parent += line;\n      }\n    }\n\n    return acc;\n  }, {\n    state: 'top',\n    ours: '',\n    theirs: '',\n    parent: ''\n  }); // this will throw if either piece is not valid JSON, that's intended\n\n  const parent = parseJSON(pieces.parent, reviver);\n  const ours = parseJSON(pieces.ours, reviver);\n  const theirs = parseJSON(pieces.theirs, reviver);\n  return prefer === 'ours' ? resolve(parent, ours, theirs) : resolve(parent, theirs, ours);\n};\n\nconst isObj = obj => obj && typeof obj === 'object';\n\nconst copyPath = (to, from, path, i) => {\n  const p = path[i];\n\n  if (isObj(to[p]) && isObj(from[p]) && Array.isArray(to[p]) === Array.isArray(from[p])) {\n    return copyPath(to[p], from[p], path, i + 1);\n  }\n\n  to[p] = from[p];\n}; // get the diff from parent->ours and applying our changes on top of theirs.\n// If they turned an object into a non-object, then put it back.\n\n\nconst resolve = (parent, ours, theirs) => {\n  const dours = diff(parent, ours);\n\n  for (let i = 0; i < dours.length; i++) {\n    if (globalObjectProperties.find(prop => dours[i].path.includes(prop))) {\n      continue;\n    }\n\n    try {\n      diffApply(theirs, [dours[i]]);\n    } catch (e) {\n      copyPath(theirs, ours, dours[i].path, 0);\n    }\n  }\n\n  return theirs;\n};\n\nmodule.exports = Object.assign(parseConflictJSON, {\n  isDiff\n});","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/parse-conflict-json/lib/index.js"],"names":["parseJSON","require","diff","diffApply","globalObjectProperties","Object","getOwnPropertyNames","prototype","stripBOM","content","toString","charCodeAt","slice","PARENT_RE","OURS_RE","THEIRS_RE","END_RE","isDiff","str","match","parseConflictJSON","reviver","prefer","TypeError","pieces","split","reduce","acc","line","state","ours","theirs","parent","resolve","isObj","obj","copyPath","to","from","path","i","p","Array","isArray","dours","length","find","prop","includes","e","module","exports","assign"],"mappings":"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","sourcesContent":["const parseJSON = require('json-parse-even-better-errors')\nconst { diff } = require('just-diff')\nconst { diffApply } = require('just-diff-apply')\n\nconst globalObjectProperties = Object.getOwnPropertyNames(Object.prototype)\n\nconst stripBOM = content => {\n  content = content.toString()\n  // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1)\n  }\n  return content\n}\n\nconst PARENT_RE = /\\|{7,}/g\nconst OURS_RE = /<{7,}/g\nconst THEIRS_RE = /={7,}/g\nconst END_RE = />{7,}/g\n\nconst isDiff = str =>\n  str.match(OURS_RE) && str.match(THEIRS_RE) && str.match(END_RE)\n\nconst parseConflictJSON = (str, reviver, prefer) => {\n  prefer = prefer || 'ours'\n  if (prefer !== 'theirs' && prefer !== 'ours') {\n    throw new TypeError('prefer param must be \"ours\" or \"theirs\" if set')\n  }\n\n  str = stripBOM(str)\n\n  if (!isDiff(str)) {\n    return parseJSON(str)\n  }\n\n  const pieces = str.split(/[\\n\\r]+/g).reduce((acc, line) => {\n    if (line.match(PARENT_RE)) {\n      acc.state = 'parent'\n    } else if (line.match(OURS_RE)) {\n      acc.state = 'ours'\n    } else if (line.match(THEIRS_RE)) {\n      acc.state = 'theirs'\n    } else if (line.match(END_RE)) {\n      acc.state = 'top'\n    } else {\n      if (acc.state === 'top' || acc.state === 'ours') {\n        acc.ours += line\n      }\n      if (acc.state === 'top' || acc.state === 'theirs') {\n        acc.theirs += line\n      }\n      if (acc.state === 'top' || acc.state === 'parent') {\n        acc.parent += line\n      }\n    }\n    return acc\n  }, {\n    state: 'top',\n    ours: '',\n    theirs: '',\n    parent: '',\n  })\n\n  // this will throw if either piece is not valid JSON, that's intended\n  const parent = parseJSON(pieces.parent, reviver)\n  const ours = parseJSON(pieces.ours, reviver)\n  const theirs = parseJSON(pieces.theirs, reviver)\n\n  return prefer === 'ours'\n    ? resolve(parent, ours, theirs)\n    : resolve(parent, theirs, ours)\n}\n\nconst isObj = obj => obj && typeof obj === 'object'\n\nconst copyPath = (to, from, path, i) => {\n  const p = path[i]\n  if (isObj(to[p]) && isObj(from[p]) &&\n      Array.isArray(to[p]) === Array.isArray(from[p])) {\n    return copyPath(to[p], from[p], path, i + 1)\n  }\n  to[p] = from[p]\n}\n\n// get the diff from parent->ours and applying our changes on top of theirs.\n// If they turned an object into a non-object, then put it back.\nconst resolve = (parent, ours, theirs) => {\n  const dours = diff(parent, ours)\n  for (let i = 0; i < dours.length; i++) {\n    if (globalObjectProperties.find(prop => dours[i].path.includes(prop))) {\n      continue\n    }\n    try {\n      diffApply(theirs, [dours[i]])\n    } catch (e) {\n      copyPath(theirs, ours, dours[i].path, 0)\n    }\n  }\n  return theirs\n}\n\nmodule.exports = Object.assign(parseConflictJSON, { isDiff })\n"]},"metadata":{},"sourceType":"script"}